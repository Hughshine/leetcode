## 5. 最长回文串

核心，奇偶性区分

### 与反串做最长子串匹配 + 位置验证

回文串即正反相同的串，因而可以直接找原串与反串的最长公共子串；但注意，找到的最长公共子串可能并不对应原串的的子串，所以在dp的时候要做位置验证，确定这两个更长的串对应原串里的同一个子串。时间复杂度为$O(n^2)$。空间复杂度可以为O(n)。

### 基本回文串的动态规划拓张

第二中动态规划算法：最小的回文串分别为a, aa 形式，即偶数或奇数形式，我们用R(i, j) = true/false表示第i-j位为回文串的情况。初始化矩阵对角线为1、对每个R(i, i+1)进行判断。矩阵的增长由对角线向右上角增长，对于奇数位与偶数位要分别增长，一旦遇到false，对应循环可以直接break，因为回文串的任意中心串都是回文串。时间复杂度O(n^2)但是算有剪枝，如果以每个/两个字符为中心的回文串长度较小，会相对快（其实和暴力枚举法很像）。（其实空间复杂度可以为O(1)）

### 暴力

以每个字符、每相邻两个字符为中心，向外拓张，失败即向右移动，时间复杂度O(n^2), 空间复杂度为O(1)；认为是这三种最好写的解

> Manacher 算法 时间可以达到O(n)，但是比较偏，是字符串处理算法，类似KMP

### 注意

string.substr(start, len);

## 10. regular expr matching

> 递归的想法，都做了好久，还是最慢的


## recursive

递归有些像“决策树”，优先想好如何分叉，什么条件做主干，对于算法的复杂度、实现难度关系大。比如判断是否pattern的第二位是"*"应优先（作为第一层循环）于判断string和pattern的首字符是否match，因为两者不是独立的，是否是真正的“match”依赖于后面的 “*”，如果后面的“*”无意义，则这一次判断就没有意义。

另，`string[string.length()]=''`, 并不会出现越界错误

```c++
        bool isMatch(string s, string p) {
        if(p.empty()) 
            return s.empty();
        // if(p.length()==1) {
        //     return  (s[0] == p[0] || p[0] == '.') && s.length()==1;
        // }
        if(p[1] == '*') {
            return isMatch(s, p.substr(2)) || !s.empty() && (s[0] == p[0]||p[0]=='.') && isMatch(s.substr(1), p);
        } else {
            return !s.empty() && (s[0] == p[0] || p[0] == '.') && isMatch(s.substr(1), p.substr(1));
        }
        
    }
```

## dp

自己的思路真的乱，声明的那些地方就更不要错了；

这道题一看就可以dp，更长串的匹配由子串的匹配结果增长得到。dp的原点是0长度串的匹配，所以需要m+1 * n+1大小数组。

```c++
dp[i][j] = p[j-1] != '*' ? dp[i-1][j-1] && s[i-1] = p[j-1] (额外算上'.'的匹配)
    : dp[i][j-2] // 1. '*' 的作用是前一个字符出现0次
    || dp[i-1][j] && s[i-1] == p[j-2] (额外算上'.'的匹配) // 2. '*' 的作用是前一个字符出现多一次（即若干次）, 相同长度的pattern，可以确认的目标串更长 // **注意，两者情况的总和一定要是'*'可能情况的全集
```

自己开始的思路是，'*' 要不相当于删去前一个字符，要不等同于没有，如此则少了“匹配任意个前面字符的情况”。

动态规划的矩阵，增长的方式一般不会仅是一个方向；如果少考虑了情况，可能就会出现这种错误。（递推关系一定要能表示全集）。

