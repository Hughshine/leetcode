## 求逆序数

### 归并

```c++
class Solution {
public:
    int _res;

    inline void swap(int& a, int& b) {
        int tmp = a;
        a = b;
        b = tmp;
    }

    void merge_sort_and_count(vector<int>& nums, int start, int end) {
        if(start == end) return;
        if(start == end -1 && nums[start] > nums[end]) {
            swap(nums[start], nums[end]);
            _res++;
            return;
        }

        int mid = (start + end) / 2;
        merge_sort_and_count(nums, start, mid);
        merge_sort_and_count(nums, mid+1, end);
        vector<int> tmp(end-start+1);
        int p1=start, p2=mid+1, e1=mid, e2=end;
        int i=0;
        while(p1 <= e1 && p2 <= e2) {
            if(nums[p1] <= nums[p2]) {
                tmp[i++] = nums[p1++];
            } else {
                _res += p2-i-start;
                tmp[i++] = nums[p2++];
            }
        }
        while(p1 <= e1) {
            tmp[i++] = nums[p1++];
        }
        while(p2 <= e2) {
            _res += p2-i-start;
            tmp[i++] = nums[p2++];
        }
        for(int i=0; i<tmp.size(); i++) {
            nums[start+i] = tmp[i];
        }
        return;
    }

    int reversePairs(vector<int>& nums) {
        if(nums.size() < 1) return 0;
        _res=0;
        merge_sort_and_count( nums, 0, nums.size()-1);
        return _res;
    }
};
```

### 树状数组

树状数组用来维护前缀和。查逆序对，实际要找对于每个位置的数字，它的前面有几个比它小的；即需要维护一个计数数组，并使用树状数组记录它的前缀和。

从树状数组得到前缀和的复杂度为O(logn), 修改原数组某元素，调整树结构，也是O(logn)

要看一看高级数据结构，明天开始看。



